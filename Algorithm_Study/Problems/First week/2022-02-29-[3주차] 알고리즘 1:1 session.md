---
title: "[22.02.29] ì•Œê³ ë¦¬ì¦˜ 3ì£¼ì°¨ - 1:1 session"
date: 2022-02-27 02:00:28 -0400
toc: true
toc_sticky: true
categories: Algorithm_Problems
---

# [3ì£¼ì°¨] ì•Œê³ ë¦¬ì¦˜ 1:1 session : ì•„ì§ ì§„í–‰ ì¤‘ â° 

<div class="notice--primary" markdown="1">
ğŸ“œ [<u>2022.02.29</u> ì €ë… ğŸ¤”ì‹œ ì§„í–‰] 
</div>  

## ğŸ’¬ [Leetcode - Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/) 

### ğŸ“„ ë¬¸ì œ ì„¤ëª… 

International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:

- `'a'` maps to `".-"`,
- `'b'` maps to `"-..."`,
- `'c'` maps to `"-.-."`, and so on.

For convenience, the full table for the `26` letters of the English alphabet is given below:

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] 
```
Given an array of strings `words` where each word can be written as a concatenation of the Morse code of each letter.

- For example, `"cab"` can be written as `"-.-..--..."`, which is the concatenation of `"-.-.", ".-"`, and `"-..."`. We will call such a concatenation the **transformation** of a word.

Return *the number of different <strong>transformations</strong> among all words we have*.

### â›”ï¸ ì œí•œì‚¬í•­
- 1 <= words.length <= 100
- 1 <= words[i].length <= 12
- words[i] consists of lowercase English letters.

### ğŸ’­ ì…ì¶œë ¥ ì˜ˆ

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #1</u>     

[ì…ë ¥]   

   ```python
words = ["gin","zen","gig","msg"]
   ```             
      
    
[ì¶œë ¥]    

   ```python    
2        
   ```
</div>   


<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #2</u>     

[ì…ë ¥]   

   ```python
words = ["a"]    
   ```             
      
    
[ì¶œë ¥]    

   ```python    
1       
   ```
   
</div>    

### âœï¸ Question Clarifying & Time, Space Complexity 


   ```python
"""
const template = {
  firstStep: {
    I: array of str, 
    O: int, 
    C: 1 <= words.length <= 100, 1 <= words[i].length <= 12, words[i] consists of lowercase English letters.
    E: words arrayì˜ ê¸¸ì´ê°€ 1ì¼ë•Œ (elementê°€ í•˜ë‚˜ì¼ ë•Œ) -> ë¬´ì¡°ê±´ 1
  },
  secondStep: {
    DS: 'HashTable',
    Alg: 'ì•„ë§ˆ ì €ì¥í•˜ê³ , ìˆìœ¼ë©´ resultë¥¼ 1ì”© ëŠ˜ë¦¬ëŠ” ë°©ë²•? -> ë§ˆì§€ë§‰ì— í•œêº¼ë²ˆì— ì„¸ëŠ” ê²Œ ë¹ ë¥¼ê¹Œ?(X)',
    bruteForce: solution = () => {
        // pseudo code
        1. ì´ì¤‘ forë¬¸ ëŒë ¤ì„œ ê¸€ì í•˜ë‚˜ì”© ëª¨ìŠ¤ ë¶€í˜¸ë¡œ ë³€í™˜
        2. morseWordë¼ëŠ” stringì— ì´ì–´ ë¶™ì¸ë‹¤.
        3. hashTableì— ìˆìœ¼ë©´ result +1, ì—†ìœ¼ë©´ ì¶”ê°€
        * ì†Œì†Œí•˜ê²Œ ëª¨ìŠ¤ë¶€í˜¸ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œë¡œ ë³€í™˜í›„, indexë¡œ ì°¾ê¸° ì •ë„ëŠ”~
    }
    time: O(N*M^2) -> ì´ ë•Œ Mì€ word ë¬¸ì ê°œìˆ˜ë“¤ ì¤‘ ìµœëŒ“ê°’,
    space: O(N) -> hashTableëŠ” ìµœëŒ€ N
  },
  thirdStep: {
    DS: 'ë™ì¼í•˜ê²Œ HashTable',
    Alg: 'ê° stringì„ ì´ì–´ë¶™ì´ëŠ” ëŒ€ì‹ (+ operation) arrayì— ë„£ê³ , join() ì‚¬ìš© -> O(M^2)ì—ì„œ O(M)ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ ìˆìŒ -> ëŒ€ì‹  Spaceê°€ O(MN)',
    optimalSolution: solution = () => {
        // pseudo code
        1. ì´ì¤‘ forë¬¸ ëŒë ¤ì„œ ê¸€ì í•˜ë‚˜ì”© ëª¨ìŠ¤ ë¶€í˜¸ë¡œ ë³€í™˜
        2. ëª¨ìŠ¤ ë¶€í˜¸ arrayì— ë„£ê³ , join() ì‚¬ìš©.
        3. hashTableì— ìˆìœ¼ë©´ result +1, ì—†ìœ¼ë©´ ì¶”ê°€
        * ì†Œì†Œí•˜ê²Œ ëª¨ìŠ¤ë¶€í˜¸ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œë¡œ ë³€í™˜í›„, indexë¡œ ì°¾ê¸° ì •ë„ëŠ”~
    },
    time: O(MN),
    space: O(MN),
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ..! í™•ì¸í•©ì‹œë‹¹
    }
  },
  fifthStep: {
    testCases: (givenInput, expectedOutput, func) => {

      const result = func(givenInput)
      if(result === expectedOutput) {
         println(`SUCCESS(O)`)
      } else {
         println(`FAILED(X)`)
      }
      
    }
    // ì„±ê³µ..!
  }
}
"""

"""
   ```

### âœï¸ First Thought Solution(Explanation) 

ì´ ë¬¸ì œëŠ” **"<u>HashTable</u>"**ì„ ì´ìš©í•˜ë©´ ëœë‹¤. ë„ˆë¬´..ë»”í•˜ì§€ë§Œ.. ê·¸ë˜ë„..ğŸ‘€   

```python
class Solution1(object):
    def uniqueMorseRepresentations(self, words): 
```

ì¼ë‹¨ ëª¨ìŠ¤ ë¶€í˜¸ë¥¼ ì €ì¥í•˜ëŠ”, ë¬¸ì œì—ì„œ ì´ë¯¸ ì£¼ì–´ì ¸ ìˆë˜ `array`ë¥¼ ì„ ì–¸í•˜ê³  ì´ë¥¼ `morse`ë¼ ì´ë¦„ ë¶™ì˜€ë‹¤.        

forë¬¸ì— í•„ìš”í•œ `words` `array`ì˜ ê¸¸ì´ë„ nìœ¼ë¡œ ëª…ì‹œ!    

ê°ê°ì˜ `word`ë¥¼ ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë°”ê¾¸ì–´ ì´ì „ì— ì¡´ì¬í–ˆëŠ”ì§€ í™•ì¸í•  ë•Œ í•„ìš”í•œ `hashTable`ë„ ìƒì„±í•´ì£¼ê³ , ë§ˆì§€ë§‰ì— ë¦¬í„´í•  ê°’ì¸ `result` ë³€ìˆ˜ë„ ì„ ì–¸í•˜ê³  `0`ìœ¼ë¡œ ì´ˆê¸°í™”í•´ì¤€ë‹¤.             
 
   ```python
morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
n = len(words)

hashTable = {}

result = 0
   ```

ë‹¤ìŒìœ¼ë¡œëŠ” `array`ë¥¼ ëŒë©´ì„œ ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë°”ê¾¸ê³ , `hashTable`ì— ìˆëŠ”ì§€ í™•ì¸ í›„, ì—†ìœ¼ë©´ `result` ê°’ì„ ì¦ê°€ì‹œí‚¤ê³  `hashTable`ì— ì¶”ê°€ì‹œí‚¤ëŠ” ì‘ì—…ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì.    
ìì„¸í•œ ì„¤ëª…ì€ ì•„ë˜ ì½”ë“œì˜ ì£¼ì„ ì°¸ê³ .
      
 
   ```python
for i in range(n):
	# wordì˜ ê¸¸ì´ë¥¼ mì— ì €ì¥
	m = len(words[i])
	# í˜„ì¬ ë³´ê³  ìˆëŠ” wordë¥¼ currentWordì— ì €ì¥
	currentWord = words[i]
	# ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë³€í™˜í•œ stringì„ ì €ì¥í•  ë³€ìˆ˜ morseWord
	morseWord = ''
   
   # wordì˜ ê¸€ì í•˜ë‚˜í•˜ë‚˜ë¥¼ ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë³€í™˜ í›„, morseWordì— ì´ì–´ ë¶™ì¸ë‹¤.
   # ë§Œì•½ hashTableì— ì—†ë‹¤ë©´ ì¶”ê°€ í›„, Result ê°’ 1 ì¦ê°€ì‹œí‚´         
	for j in range(m):
		# ord() -> charì„ ë§ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œ int í˜•íƒœë¡œ ë°”ê¿”ì¤€ë‹¤.
		temp = ord(currentWord[j]) - 97
		morseWord += morse[temp]
            
		if morseWord not in hashTable:
			hashTable[morseWord] = True
			result += 1

   ```

ë§ˆì§€ë§‰ìœ¼ë¡œ result ê°’ì„ ë¦¬í„´í•´ì£¼ë©´ ë!    
     
   ```python
return result
   ```

     
### âœï¸ Final Code of First Thought

   ```python
class Solution1(object):
    def uniqueMorseRepresentations(self, words):
        morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
        n = len(words)

        hashTable = {}

        result = 0

        for i in range(n):
            m = len(words[i])
            currentWord = words[i]
            morseWord = ''
            
            for j in range(m):
                temp = ord(currentWord[j]) - 97
                morseWord += morse[temp]
            
            if morseWord not in hashTable:
                hashTable[morseWord] = True
                result += 1

        return result
   ```
   
### âœï¸ Second Thought Solution(Explanation)                 

<div class="notice--primary" markdown="1">
ğŸ’¡ <strong><u>ì¶”ê°€ ì§€ì‹!</u> Pythonì—ì„œ ë¬¸ìì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ë°©ë²•</strong>   

string (+) operationì€ êµ‰ì¥íˆ ë¹„íš¨ìœ¨ì ì´ë‹¤.

The reason for this is, on every â€œ+â€ operation a new string is created(Remember strings are immutable?) <strong>every single time and the existing values <u>have to be copied character by character</u></strong>.    
The time complexity of this operation is <strong>O(nÂ²)</strong>.       

Concatenating immutable sequences <u><strong>always results in a new object</strong></u>. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length.    


ğŸ“Œ <strong><u>How do we overcome this?</u> : <u>list & str.join()</u></strong>          

Well, itâ€™s better off <u><strong>using a list to store all the strings to be concatenated and join them using the str.join() method</strong></u>.    

str.join() takes <strong><u>an iterable</u> as an argument</strong> and <strong>returns a <u>string</u> which is a concatenation of all the string objects in the iterable</strong>.

This is a more efficient way to concatenate strings rather than using a â€œ+â€. <strong>The time complexity of using join() for strings is <u>O(n)</u> where n is the length of the string to be concatenated</strong>.      


Having said that, the difference in the execution time will be significant only if the strings to be concatenated is long. For smaller strings, we may not see a huge difference.     

</div>
      
 
   ```python
for i in range(n):
	m = len(words[i])
	currentWord = words[i]
	# ê° ë³€í™˜í•œ ëª¨ìŠ¤ë¶€í˜¸ ì €ì¥í•˜ëŠ” list
	morseWord_list = []
            
	for j in range(m):
		temp = ord(currentWord[j]) - 97
		# listì— ì €ì¥ í›„, 
		morseWord_list.append(morse[temp])
		
	# joinì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½
	morseWord = ''.join(morseWord_list)
   ```
     
### âœï¸ Final Code of Second Thought

   ```python
class Solution2(object):
    def uniqueMorseRepresentations(self, words):
        morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
        n = len(words)

        hashTable = {}

        result = 0

        for i in range(n):
            m = len(words[i])
            currentWord = words[i]
            morseWord_list = []
            
            for j in range(m):
                # ord() -> charì„ ë§ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œ int í˜•íƒœë¡œ ë°”ê¿”ì¤€ë‹¤.
                temp = ord(currentWord[j]) - 97
                # listì— ì €ì¥ í›„, joinì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½
                morseWord_list.append(morse[temp])

            morseWord = ''.join(morseWord_list)
            
            if morseWord not in hashTable:
                hashTable[morseWord] = True
                result += 1

        return result
   ```

   	    
<div class="notice--primary" markdown="1">
ğŸŒŸ <strong>[10ì£¼ì°¨] 1 Session ì˜ <u>í¬ì¸íŠ¸</u></strong>    

	- ë‹¹ì—°íˆ ì¼ë‹¨.. HashTable    
	- ord() -> charì„ ë§ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œ int í˜•íƒœë¡œ ë°”ê¿”ì¤€ë‹¤.    
	- string (+) operationë³´ë‹¤ëŠ”, ê°ê°ì˜ ë¬¸ìë‚˜ elementë“¤ì„ listì— ì €ì¥ í›„, join() í†µí•´ í•©ì¹˜ëŠ” ê²ƒì´ Time Complexity ìƒìœ¼ë¡œ ë” íš¨ìœ¨ì .       
     
</div>

## ğŸ”— ì°¸ê³  ì‚¬ì´íŠ¸  

[**How To Efficiently Concatenate Strings In Python : 
Pythonì—ì„œ ë¬¸ìì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ë°©ë²•**](https://python.plainenglish.io/concatenating-strings-efficiently-in-python-9bfc8e8d6f6e)
