# [3ì£¼ì°¨] ì•Œê³ ë¦¬ì¦˜ 1:1 session 

<div class="notice--primary" markdown="1">
ğŸ“œ [<u>2022.03.03</u> ì €ë… ğŸ¤”ì‹œ ì§„í–‰] 
</div>  

## ğŸ’¬ [Leetcode - Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/) 

### ğŸ“„ ë¬¸ì œ ì„¤ëª… 

International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:

- `'a'` maps to `".-"`,
- `'b'` maps to `"-..."`,
- `'c'` maps to `"-.-."`, and so on.

For convenience, the full table for the `26` letters of the English alphabet is given below:

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] 
```
Given an array of strings `words` where each word can be written as a concatenation of the Morse code of each letter.

- For example, `"cab"` can be written as `"-.-..--..."`, which is the concatenation of `"-.-.", ".-"`, and `"-..."`. We will call such a concatenation the **transformation** of a word.

Return *the number of different <strong>transformations</strong> among all words we have*.

### â›”ï¸ ì œí•œì‚¬í•­
- 1 <= words.length <= 100
- 1 <= words[i].length <= 12
- words[i] consists of lowercase English letters.

### ğŸ’­ ì…ì¶œë ¥ ì˜ˆ

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #1</u>     

[ì…ë ¥]   

   ```python
words = ["gin","zen","gig","msg"]
   ```             
      
    
[ì¶œë ¥]    

   ```python    
2        
   ```
</div>   


<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #2</u>     

[ì…ë ¥]   

   ```python
words = ["a"]    
   ```             
      
    
[ì¶œë ¥]    

   ```python    
1       
   ```
   
</div>    

### âœï¸ Question Clarifying & Time, Space Complexity 


   ```python
"""
const template = {
  firstStep: {
    I: array of str, 
    O: int, 
    C: 1 <= words.length <= 100, 1 <= words[i].length <= 12, words[i] consists of lowercase English letters.
    E: words arrayì˜ ê¸¸ì´ê°€ 1ì¼ë•Œ (elementê°€ í•˜ë‚˜ì¼ ë•Œ) -> ë¬´ì¡°ê±´ 1
  },
  secondStep: {
    DS: 'HashTable',
    Alg: 'ì•„ë§ˆ ì €ì¥í•˜ê³ , ìˆìœ¼ë©´ resultë¥¼ 1ì”© ëŠ˜ë¦¬ëŠ” ë°©ë²•? -> ë§ˆì§€ë§‰ì— í•œêº¼ë²ˆì— ì„¸ëŠ” ê²Œ ë¹ ë¥¼ê¹Œ?(X)',
    bruteForce: solution = () => {
        // pseudo code
        1. ì´ì¤‘ forë¬¸ ëŒë ¤ì„œ ê¸€ì í•˜ë‚˜ì”© ëª¨ìŠ¤ ë¶€í˜¸ë¡œ ë³€í™˜
        2. morseWordë¼ëŠ” stringì— ì´ì–´ ë¶™ì¸ë‹¤.
        3. hashTableì— ìˆìœ¼ë©´ result +1, ì—†ìœ¼ë©´ ì¶”ê°€
        * ì†Œì†Œí•˜ê²Œ ëª¨ìŠ¤ë¶€í˜¸ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œë¡œ ë³€í™˜í›„, indexë¡œ ì°¾ê¸° ì •ë„ëŠ”~
    }
    time: O(N*M^2) -> ì´ ë•Œ Mì€ word ë¬¸ì ê°œìˆ˜ë“¤ ì¤‘ ìµœëŒ“ê°’,
    space: O(N) -> hashTableëŠ” ìµœëŒ€ N
  },
  thirdStep: {
    DS: 'ë™ì¼í•˜ê²Œ HashTable',
    Alg: 'ê° stringì„ ì´ì–´ë¶™ì´ëŠ” ëŒ€ì‹ (+ operation) arrayì— ë„£ê³ , join() ì‚¬ìš© -> O(M^2)ì—ì„œ O(M)ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ ìˆìŒ -> ëŒ€ì‹  Spaceê°€ O(MN)',
    optimalSolution: solution = () => {
        // pseudo code
        1. ì´ì¤‘ forë¬¸ ëŒë ¤ì„œ ê¸€ì í•˜ë‚˜ì”© ëª¨ìŠ¤ ë¶€í˜¸ë¡œ ë³€í™˜
        2. ëª¨ìŠ¤ ë¶€í˜¸ arrayì— ë„£ê³ , join() ì‚¬ìš©.
        3. hashTableì— ìˆìœ¼ë©´ result +1, ì—†ìœ¼ë©´ ì¶”ê°€
        * ì†Œì†Œí•˜ê²Œ ëª¨ìŠ¤ë¶€í˜¸ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œë¡œ ë³€í™˜í›„, indexë¡œ ì°¾ê¸° ì •ë„ëŠ”~
    },
    time: O(MN),
    space: O(MN),
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ..! í™•ì¸í•©ì‹œë‹¹
    }
  },
  fifthStep: {
    testCases: (givenInput, expectedOutput, func) => {

      const result = func(givenInput)
      if(result === expectedOutput) {
         println(`SUCCESS(O)`)
      } else {
         println(`FAILED(X)`)
      }
      
    }
    // ì„±ê³µ..!
  }
}
"""

"""
   ```

### âœï¸ First Thought Solution(Explanation) 

ì´ ë¬¸ì œëŠ” **"<u>HashTable</u>"**ì„ ì´ìš©í•˜ë©´ ëœë‹¤. ë„ˆë¬´..ë»”í•˜ì§€ë§Œ.. ê·¸ë˜ë„..ğŸ‘€   

```python
class Solution1(object):
    def uniqueMorseRepresentations(self, words): 
```

ì¼ë‹¨ ëª¨ìŠ¤ ë¶€í˜¸ë¥¼ ì €ì¥í•˜ëŠ”, ë¬¸ì œì—ì„œ ì´ë¯¸ ì£¼ì–´ì ¸ ìˆë˜ `array`ë¥¼ ì„ ì–¸í•˜ê³  ì´ë¥¼ `morse`ë¼ ì´ë¦„ ë¶™ì˜€ë‹¤.        

forë¬¸ì— í•„ìš”í•œ `words` `array`ì˜ ê¸¸ì´ë„ nìœ¼ë¡œ ëª…ì‹œ!    

ê°ê°ì˜ `word`ë¥¼ ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë°”ê¾¸ì–´ ì´ì „ì— ì¡´ì¬í–ˆëŠ”ì§€ í™•ì¸í•  ë•Œ í•„ìš”í•œ `hashTable`ë„ ìƒì„±í•´ì£¼ê³ , ë§ˆì§€ë§‰ì— ë¦¬í„´í•  ê°’ì¸ `result` ë³€ìˆ˜ë„ ì„ ì–¸í•˜ê³  `0`ìœ¼ë¡œ ì´ˆê¸°í™”í•´ì¤€ë‹¤.             
 
   ```python
morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
n = len(words)

hashTable = {}

result = 0
   ```

ë‹¤ìŒìœ¼ë¡œëŠ” `array`ë¥¼ ëŒë©´ì„œ ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë°”ê¾¸ê³ , `hashTable`ì— ìˆëŠ”ì§€ í™•ì¸ í›„, ì—†ìœ¼ë©´ `result` ê°’ì„ ì¦ê°€ì‹œí‚¤ê³  `hashTable`ì— ì¶”ê°€ì‹œí‚¤ëŠ” ì‘ì—…ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì.    
ìì„¸í•œ ì„¤ëª…ì€ ì•„ë˜ ì½”ë“œì˜ ì£¼ì„ ì°¸ê³ .
      
 
   ```python
for i in range(n):
	# wordì˜ ê¸¸ì´ë¥¼ mì— ì €ì¥
	m = len(words[i])
	# í˜„ì¬ ë³´ê³  ìˆëŠ” wordë¥¼ currentWordì— ì €ì¥
	currentWord = words[i]
	# ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë³€í™˜í•œ stringì„ ì €ì¥í•  ë³€ìˆ˜ morseWord
	morseWord = ''
   
   # wordì˜ ê¸€ì í•˜ë‚˜í•˜ë‚˜ë¥¼ ëª¨ìŠ¤ë¶€í˜¸ë¡œ ë³€í™˜ í›„, morseWordì— ì´ì–´ ë¶™ì¸ë‹¤.
   # ë§Œì•½ hashTableì— ì—†ë‹¤ë©´ ì¶”ê°€ í›„, Result ê°’ 1 ì¦ê°€ì‹œí‚´         
	for j in range(m):
		# ord() -> charì„ ë§ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œ int í˜•íƒœë¡œ ë°”ê¿”ì¤€ë‹¤.
		temp = ord(currentWord[j]) - 97
		morseWord += morse[temp]
            
		if morseWord not in hashTable:
			hashTable[morseWord] = True
			result += 1

   ```

ë§ˆì§€ë§‰ìœ¼ë¡œ result ê°’ì„ ë¦¬í„´í•´ì£¼ë©´ ë!    
     
   ```python
return result
   ```

     
### âœï¸ Final Code of First Thought

   ```python
class Solution1(object):
    def uniqueMorseRepresentations(self, words):
        morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
        n = len(words)

        hashTable = {}

        result = 0

        for i in range(n):
            m = len(words[i])
            currentWord = words[i]
            morseWord = ''
            
            for j in range(m):
                temp = ord(currentWord[j]) - 97
                morseWord += morse[temp]
            
            if morseWord not in hashTable:
                hashTable[morseWord] = True
                result += 1

        return result
   ```
   
### âœï¸ Second Thought Solution(Explanation)                 

<div class="notice--primary" markdown="1">
ğŸ’¡ <strong><u>ì¶”ê°€ ì§€ì‹!</u> Pythonì—ì„œ ë¬¸ìì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ë°©ë²•</strong>   

string (+) operationì€ êµ‰ì¥íˆ ë¹„íš¨ìœ¨ì ì´ë‹¤.

The reason for this is, on every â€œ+â€ operation a new string is created(Remember strings are immutable?) <strong>every single time and the existing values <u>have to be copied character by character</u></strong>.    
The time complexity of this operation is <strong>O(nÂ²)</strong>.       

Concatenating immutable sequences <u><strong>always results in a new object</strong></u>. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length.    


ğŸ“Œ <strong><u>How do we overcome this?</u> : <u>list & str.join()</u></strong>          

Well, itâ€™s better off <u><strong>using a list to store all the strings to be concatenated and join them using the str.join() method</strong></u>.    

str.join() takes <strong><u>an iterable</u> as an argument</strong> and <strong>returns a <u>string</u> which is a concatenation of all the string objects in the iterable</strong>.

This is a more efficient way to concatenate strings rather than using a â€œ+â€. <strong>The time complexity of using join() for strings is <u>O(n)</u> where n is the length of the string to be concatenated</strong>.      


Having said that, the difference in the execution time will be significant only if the strings to be concatenated is long. For smaller strings, we may not see a huge difference.     

</div>
      
 
   ```python
for i in range(n):
	m = len(words[i])
	currentWord = words[i]
	# ê° ë³€í™˜í•œ ëª¨ìŠ¤ë¶€í˜¸ ì €ì¥í•˜ëŠ” list
	morseWord_list = []
            
	for j in range(m):
		temp = ord(currentWord[j]) - 97
		# listì— ì €ì¥ í›„, 
		morseWord_list.append(morse[temp])
		
	# joinì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½
	morseWord = ''.join(morseWord_list)
   ```
     
### âœï¸ Final Code of Second Thought

   ```python
class Solution2(object):
    def uniqueMorseRepresentations(self, words):
        morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
        n = len(words)

        hashTable = {}

        result = 0

        for i in range(n):
            m = len(words[i])
            currentWord = words[i]
            morseWord_list = []
            
            for j in range(m):
                # ord() -> charì„ ë§ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œ int í˜•íƒœë¡œ ë°”ê¿”ì¤€ë‹¤.
                temp = ord(currentWord[j]) - 97
                # listì— ì €ì¥ í›„, joinì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½
                morseWord_list.append(morse[temp])

            morseWord = ''.join(morseWord_list)
            
            if morseWord not in hashTable:
                hashTable[morseWord] = True
                result += 1

        return result
   ```

   	    
## ğŸ’¬ [Leetcode - Number of Good Pairs](https://leetcode.com/problems/number-of-good-pairs/) 

### ğŸ“„ ë¬¸ì œ ì„¤ëª…  

Given an array of integers `nums`, return *the number of <strong>good pairs</strong>*.

A pair `(i, j)` is called good if `nums[i] == nums[j]` and `i` < `j`.

### â›”ï¸ ì œí•œì‚¬í•­
- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

### ğŸ’­ ì…ì¶œë ¥ ì˜ˆ

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #1</u>     

[ì…ë ¥]   

   ```python
nums = [1,2,3,1,1,3]
   ```             
      
    
[ì¶œë ¥]    

   ```python    
4       
   ```
</div>   


<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #2</u>     

[ì…ë ¥]   

   ```python
nums = [1,1,1,1]   
   ```             
      
    
[ì¶œë ¥]    

   ```python    
6      
   ```
   
</div>    

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #3</u>     

[ì…ë ¥]   

   ```python
nums = [1,2,3]   
   ```             
      
    
[ì¶œë ¥]    

   ```python    
0      
   ```
   
</div>   

### âœï¸ Question Clarifying & Time, Space Complexity 


   ```python
"""
const template = {
  firstStep: {
    I: array of integers, 
    O: int (number of good pairs) -> A pair (i, j) is called good if nums[i] == nums[j] and i < j, 
    C: 1 <= nums.length <= 100, 1 <= nums[i] <= 100
    E: words arrayì˜ ê¸¸ì´ê°€ 1ì¼ë•Œ (elementê°€ í•˜ë‚˜ì¼ ë•Œ) -> ê·¸ëƒ¥ ë¦¬í„´ 
  },
  secondStep: {
    DS: 'HashTable',
    Alg: 'ì €ì¥ í›„ ë¹„êµ -> ìˆ˜ì‹',
    bruteForce: solution = () => {
        // pseudo code
        hashtableì— ì €ì¥ 
        ê°œìˆ˜ ë³´ê³  ìˆ˜ì‹ 
        result ë°˜í™˜
    }
    time: O(N + M) -> ì—¬ê¸°ì„œ Mì€ ìˆ«ìì˜ ì¢…ë¥˜(ìµœì•…ì˜ ê²½ìš° N),
    space: O(N)
  },
  thirdStep: {
    DS: 'HashTable',
    Alg: 'ì €ì¥ í›„ ë¹„êµ -> hashTableì˜ valueì— list ëŒ€ì‹  ê°œìˆ˜ ì €ì¥',
    optimalSolution: solution = () => {
        // pseudo code
        hashtableì— ê°œìˆ˜ë¡œ ì €ì¥ -> list ëŒ€ì‹ ! (ì¡°ê¸ˆë”...memory ì¤„ì¼ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ..)
        ê°œìˆ˜ ë³´ê³  ìˆ˜ì‹ 
        result ë°˜í™˜
        
    },
    time: O(N + M),
    space: O(N),
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ í™•ì¸í•˜ì..!
    }
  },
  fifthStep: {
    testCases: (givenInput, expectedOutput, func) => {

      const result = func(givenInput)
      if(result === expectedOutput) {
         println(`SUCCESS(O)`)
      } else {
         println(`FAILED(X)`)
      }
      
    }
    ì„±ê³µ..!
  }
}
"""
   ```

### âœï¸ First Thought Solution(Explanation) 

ì´ ë¬¸ì œ ì—­ì‹œ ì£¼ Data StructureëŠ” **"<u>HashTable</u>"**. 

í¬ì¸íŠ¸ëŠ” ìˆ˜ì‹ ì‚¬ìš©..! ì´ í¬ì¸íŠ¸ë¥¼ ë°”ë¡œ ìƒê°í•´ ë‚´ê³  ì ìš©í•´ ë‚¸ ë‚˜.. ì •ë§ ì¹­ì°¬í•´ ğŸ˜˜

```python
class Solution(object):
    def numIdenticalPairs(self, nums): 
```     

forë¬¸ì— í•„ìš”í•œ `nums` `array`ì˜ ê¸¸ì´ë„ nìœ¼ë¡œ ëª…ì‹œ!    

edge caseë¡œ `array`ì˜ ê¸¸ì´ê°€ 1ì¼ ë•ŒëŠ” 0ì„ ë¦¬í„´.    


ê°ê°ì˜ `nums`ì˜ ìˆ˜ê°€ ëª‡ ë²ˆ ë‚˜íƒ€ë‚˜ëŠ”ì§€ë¥¼ ì €ì¥í•  `hashTable`ë„ ìƒì„±í•´ì£¼ê³ , ë§ˆì§€ë§‰ì— ë¦¬í„´í•  ê°’ì¸ `result` ë³€ìˆ˜ë„ ì„ ì–¸í•˜ê³  `0`ìœ¼ë¡œ ì´ˆê¸°í™”í•´ì¤€ë‹¤.             
 
   ```python
n = len(nums)

if n == 1:
	return 0

hashTable = {}

result = 0
   ```

ë‹¤ìŒìœ¼ë¡œëŠ” `array`ë¥¼ ëŒë©´ì„œ, `hashTable`ì— ìˆëŠ”ì§€ í™•ì¸ í›„, ì—†ìœ¼ë©´ í•´ë‹¹ ê°’ì„ keyë¡œ, ì¸ë±ìŠ¤ë¥¼ ëª¨ì•„ë†“ì€ listë¥¼ valueë¡œ `hashTable`ì— ì¶”ê°€ì‹œí‚¤ëŠ” ì‘ì—…ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì.    
ìì„¸í•œ ì„¤ëª…ì€ ì•„ë˜ ì½”ë“œì˜ ì£¼ì„ ì°¸ê³ .
      
 
   ```python
for i in range(n):
	# hashTableì— ì—†ë‹¤ë©´
	if nums[i] not in hashTable:
		# í•´ë‹¹ ê°’ì„ keyë¡œ, ì¸ë±ìŠ¤ë¥¼ ëª¨ì•„ë†“ì€ listë¥¼ valueë¡œ hashTableì— ì¶”ê°€
		hashTable[nums[i]] = [i]
	else:
		# ìˆìœ¼ë©´ ë‹¨ìˆœíˆ ë¦¬ìŠ¤íŠ¸ì— append
		hashTable[nums[i]].append(i)
   ```

ì´ë ‡ê²Œ hashTableì— ê°’ì„ ì €ì¥í•˜ë©´, ì´ì œ ìˆ˜ì‹ì„ ë„£ì„ ì°¨ë¡€..!

ìƒê°í•´ë³´ë©´ ë™ì¼í•œ ê°’ì„ ê°€ì§„ ì¸ë±ìŠ¤ì˜ ê°œìˆ˜ê°€ 1 ì´ìƒì¼ ê²½ìš°(1ì´ë©´ ë™ì¼í•œ ì¸ë±ìŠ¤ê°€ ì—†ë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ ë¬´ì‹œí•˜ë©´ ë˜ê² ì§€), ì„œë¡œ ë‹¤ë¥¸ ì¡°í•© ì¤‘ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê²½ìš°ì˜ ìˆ˜ëŠ” ìˆ˜í•™ì—ì„œì˜ ì¡°í•©(n*(n-1)/2)ì˜ ìˆ˜ì™€ ë™ì¼í•¨!    

ì´ë¥¼ ì½”ë“œí™”í•´ë³´ì. 
     
   ```python
for key, val in hashTable.items():
	if len(val) > 1:
		result += len(val)*(len(val)-1)/2
   ```

ë§ˆì§€ë§‰ìœ¼ë¡œ result ë°˜í™˜!

   ```python
return result
   ```
     
### âœï¸ Final Code of First Thought

   ```python
class Solution1(object):
    def numIdenticalPairs(self, nums):
        n = len(nums)

        if n == 1:
            return 0

        hashTable = {}

        result = 0

        for i in range(n):
            if nums[i] not in hashTable:
                hashTable[nums[i]] = [i]
            else:
                hashTable[nums[i]].append(i)
        

        
        
        for key, val in hashTable.items():


            if len(val) > 1:
                result += len(val)*(len(val)-1)/2
        
        return result
   ```
   
### âœï¸ Second Thought Solution(Explanation)                 

ìƒê°í•´ë³´ë©´.. ìš°ë¦¬ëŠ” ë‹¨ìˆœíˆ ë™ì¼í•œ ê°’ì„ ê°€ì§„ ì¸ë±ìŠ¤ì˜ ê°œìˆ˜ë§Œ í•„ìš”í•˜ë‹ˆê¹Œ ì¸ë±ìŠ¤ listë¥¼ ì €ì¥í•˜ëŠ” ëŒ€ì‹  ê°œìˆ˜ë§Œ ì €ì¥í•˜ë©´ memoryê°€ ëœ ì†Œìš”ë˜ì§€ ì•Šì„ê¹Œì—ì„œ ì°©ì•ˆ..!        

ë°”ê¾¸ì–´ì•¼ í•  ë¶€ë¶„ì€ ë‹¤ìŒê³¼ ê°™ë‹¤..!  
 
   ```python
for i in range(n):
	if nums[i] not in hashTable:
		hashTable[nums[i]] = 1
	else:
		hashTable[nums[i]] += 1
        
for key, val in hashTable.items():
	if val > 1:
		result += val*(val-1)/2
   ```
     
### âœï¸ Final Code of Second Thought

   ```python
class Solution2(object):
    def numIdenticalPairs(self, nums):
        n = len(nums)

        if n == 1:
            return 0

        hashTable = {}
        
        result = 0

        for i in range(n):
            if nums[i] not in hashTable:
                hashTable[nums[i]] = 1
            else:
                hashTable[nums[i]] += 1
        
        for key, val in hashTable.items():
            if val > 1:
                result += val*(val-1)/2
        
        return result
        
   ```

### âœï¸ Did it improved?

<img width="379" alt="Screen Shot 2022-02-28 at 7 17 45 PM" src="https://user-images.githubusercontent.com/63195670/155965780-67a0e7bc-38fc-4a7a-a87e-63317fd434c9.png">    

í¥ì¹«ë¿¡.    
ì™œ memory ê·¸ëŒ€ë¡œì— ì‹œê°„ë§Œ ë” ëŠëƒì•„...ğŸ˜­    

   	    
<div class="notice--primary" markdown="1">
ğŸŒŸ <strong>[10ì£¼ì°¨] 1 Session ì˜ <u>í¬ì¸íŠ¸</u></strong>    

	- ë‹¹ì—°íˆ ì¼ë‹¨.. HashTable    
	- ord() -> charì„ ë§ëŠ” ì•„ìŠ¤í‚¤ ì½”ë“œ int í˜•íƒœë¡œ ë°”ê¿”ì¤€ë‹¤.    
	- string (+) operationë³´ë‹¤ëŠ”, ê°ê°ì˜ ë¬¸ìë‚˜ elementë“¤ì„ listì— ì €ì¥ í›„, join() í†µí•´ í•©ì¹˜ëŠ” ê²ƒì´ Time Complexity ìƒìœ¼ë¡œ ë” íš¨ìœ¨ì .  
	- ìˆ˜ì‹ ê°€ëŠ¥í•˜ë‹¤ë©´! ìƒê°í•´ì„œ ë„£ì–´ë¼! í› ~ì›”ì”¬ ë¹ ë¥´ë‹¤..!     
     
</div>
