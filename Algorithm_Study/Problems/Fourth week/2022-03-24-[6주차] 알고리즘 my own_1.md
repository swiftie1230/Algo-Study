---
title: "[22.03.25] ì•Œê³ ë¦¬ì¦˜ 6ì£¼ì°¨ - my own_1"
date: 2022-03-25 06:00:28 -0400
toc: true
toc_sticky: true
categories: Algorithm_Problems
---

# [6ì£¼ì°¨] ì•Œê³ ë¦¬ì¦˜ my own ì²« ë²ˆì§¸ ë¬¸ì œ

## ğŸ’¬ [Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) 

### ğŸ“„ ë¬¸ì œ ì„¤ëª…  

You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```python
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

### ğŸ—’ Follow-up

- You may only use constant extra space.
- The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.

### â›”ï¸ ì œí•œì‚¬í•­
- The number of nodes in the tree is in the range `[0, 212 - 1]`.
- `-1000 <= Node.val <= 1000`

### ğŸ’­ ì…ì¶œë ¥ ì˜ˆ

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #1</u>     

<img width="466" alt="Screen Shot 2022-03-25 at 5 47 38 PM" src="https://user-images.githubusercontent.com/63195670/160087220-192522bc-ea16-474c-8cc9-24c6ef9a62a9.png">            

[ì…ë ¥]   

   ```python
root = [1,2,3,4,5,6,7] 
   ```             
      
    
[ì¶œë ¥]    

   ```python    
[1,#,2,3,#,4,5,6,7,#]      
   ```
</div>   


<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #2</u>          

[ì…ë ¥]   

   ```python
root = []
   ```             
      
    
[ì¶œë ¥]    

   ```python    
[]    
   ```
   
</div>    


### âœï¸ Question Clarifying & Time, Space Complexity 


   ```python
'''
const template = {
  firstStep: {
    I: perfect binary tree -> all leaves are on the same level, and every parent has two children, 
    O: perfect binary tree -> populate each next pointer to point to its next right node, 
    C: The number of nodes in the tree is in the range [0, 2^12 - 1], -1000 <= Node.val <= 1000,
    E: ê¸¸ì´ê°€ 0ì¸ treeëŠ” ê·¸ëŒ€ë¡œ ë¦¬í„´
  },
  secondStep: {
    DS: 'BFS? -> level by level',
    Alg: 'ìˆìœ¼ë©´ nextë¡œ, ì—†ìœ¼ë©´ #',
    bruteForce: solution = () => {
        // pseudo code
        class Solution(object):
            def connect(self, root):
                if not root:
                    return root

                queue = deque([root, "#"])
                before_node = None

                while queue:
                    current = queue.popleft()
                    
                    if not queue:
                        break

                    if current == "#":
                        before_node = None
                        queue.append("#")
                        continue
                    
                    if before_node:
                        before_node.next = current
                    
                    before_node = current
                    
                    if not current.left or not current.right:
                        continue
                    
                    queue.append(current.left)
                    queue.append(current.right)
                        
                return root

            
    }
    time: O(N*N) : Nê°œì˜ ë…¸ë“œ,
    space: O(N) : queue (ë…¸ë“œì˜ ê°œìˆ˜ê°€ ì¦ê°€í•  ìˆ˜ë¡ ì¦ê°€)
  },
  thirdStep: {
    DS: 'link list, pointer',
    Alg: 'use cur and next pointer to store first node at each level. we exchange cur and next every time when cur is the last node at each level',
    bruteForce: solution = () => {
        // pseudo code
        if not root:
            return None
        cur  = root
        next = root.left

        while cur.left :
            cur.left.next = cur.right
            if cur.next:
                cur.right.next = cur.next.left
                cur = cur.next
            else:
                cur = next
                next = cur.left

    }
    time: O(N),
    space: O(1) -> cur, next ê³ ì •ëœ ë³€ìˆ˜ë§Œ ì‚¬ìš©
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ í™•ì¸í•˜ì!
    }
  },
  fifthStep: {
    testCases: (givenInput, expectedOutput, func) => {

      const result = func(givenInput)
      if(result === expectedOutput) {
         println(`SUCCESS(O)`)
      } else {
         println(`FAILED(X)`)
      }
      
    }
    SUCCESS! ì„±ê³µ
  }
}
'''
   ```

### âœï¸ First Thought Solution(Explanation) 

ì²˜ìŒ ì´ ë¬¸ì œë¥¼ ì ‘í•˜ê³ , ê³ ë¯¼ ëì— Brute Forceë¼ê³  í•  ìˆ˜ ìˆëŠ”.. ì™„ì „íˆ ë‚  ê²ƒì˜ my ìƒê°ì€       

1.  ë”± ë´ë„ **levelìˆœ**ìœ¼ë¡œ ëŒë©´ì„œ `next`ë¥¼ ì§€ì •í•˜ê³  ì €ì¥í•´ì•¼ í•˜ë¯€ë¡œ, `level-by-level` ì ‘ê·¼ì„ í•´ì•¼ í•  ê²ƒ ê°™ì•˜ìŒ â†’ **<u>BFS ìˆœíšŒ ë°©ë²• ì‚¬ìš©</u>**
2.  **<u>ë‹¤ìŒ levelë¡œ ë„˜ì–´ê°ˆ ë•Œ</u>** `next` ê°’ì€ ë”°ë¡œ ì§€ì •í•  í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ **<u>ì´ë¥¼ êµ¬ë¶„í•  ìˆ˜ ìˆëŠ” ì§€í‘œ</u>ë¥¼ ì„¤ì •**í•´ì•¼ í•¨

ì´ ë‘ê°€ì§€ì˜€ë‹¤.          

`BFS`ì—ì„œ ì‚¬ìš©í•˜ëŠ” íë¥¼ ì‚¬ìš©í•˜ì—¬ `levelë³„`ë¡œ ì ‘ê·¼í•œ í›„, `next`ë¥¼ ì§€ì •í•˜ëŠ” ë°©ë²•ì„ ìƒê°í–ˆìŒ!      

<div class="notice--primary" markdown="1">
ğŸ™‹ğŸ»â€â™€ï¸ <strong><u>ì—¬ê¸°ì„œ ì ê¹!</u> <u>queueì— ê°’ë“¤ì„ ì¶”ê°€í•˜ê³  ì‚­ì œí•˜ëŠ” ì—°ì‚°ì— ëŒ€í•´ ì•Œì•„ë³´ì</u></strong>    

íŒŒì´ì¬ì—ì„œëŠ” queueë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ë°©ì‹ì´ ìˆì§€ë§Œ, ë³´í†µ <code>deque</code>ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì´ ê°€ì¥ ì¶”ì²œë˜ê³  ìˆë‹¤.       
<code>collections</code> ëª¨ë“ˆì˜ <code>deque</code>ëŠ” <code>double-ended queue</code>ì˜ ì•½ìë¡œ ë°ì´í„°ë¥¼ ì–‘ë°©í–¥ì—ì„œ ì¶”ê°€í•˜ê³  ì œê±°í•  ìˆ˜ ìˆëŠ” ìë£Œêµ¬ì¡°ì´ë‹¤.       

<code>from collections import deque</code>   

<code>deque</code>ë¥¼ <code>import</code>í•´ì£¼ëŠ” ê±´ ê¸°ë³¸!            

ğŸ“Œ <strong><u>queue ìƒì„±</u></strong>   

<code>queue = deque()</code>     
ë„ˆë¬´..ê°„ë‹¨!      

ë§Œì•½ íŠ¹ì • ê°’ì„ ë„£ì€ ì±„ë¡œ queueë¥¼ ìƒì„±í•˜ê³  ì‹¶ë‹¤ë©´,    

<code>queue = deque([í•´ë‹¹ ê°’ë“¤])</code>
       

ğŸ“Œ <strong><u>queueì— ê°’ ì¶”ê°€</u>(ë„£ëŠ”ë‹¤ëŠ” ëŠë‚Œ)</strong>    

<code>queue.append(ì¶”ê°€í•  í•´ë‹¹ ê°’)</code>        

ğŸ“Œ <strong><u>queueì— ê°’ ì‚­ì œ</u>(í•˜ë‚˜ì”© ì²˜ìŒì— ë„£ì€ ê°’ì„ êº¼ë‚´ì˜¨ë‹¤ëŠ” ëŠë‚Œ)</strong>    

<code>queue.popleft()</code>      

</div>



ê·¸ëŸ¼ ë³¸ê²©ì ìœ¼ë¡œ ì½”ë“œë¥¼ í•œ ë²ˆ ì‘ì„±í•´ë³´ì!          

```python
from collections import deque

class Solution(object):
    def connect(self, root):
```   

ì¼ë‹¨ ì²˜ìŒ `input`ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ì¦‰, íŠ¸ë¦¬ ìì²´ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ê·¸ëƒ¥ ê·¸ ìì²´ë¥¼ ë‹¤ì‹œ ë¦¬í„´í•˜ë©´ ë¨. (nextë¼ê³  í•  ê²Œ ì—†ìœ¼ë‹ˆê¹Œ)             

```python
if not root:
	return root
```

ë‹¤ìŒìœ¼ë¡œ ì²˜ìŒ ì´ ë¬¸ì œë¥¼ ë³´ê³  ìƒê°í–ˆë˜ **<u>ì¤‘ìš”í•œ Problem</u>**!     
ì¼ë‹¨ **`next`ë¥¼ ì§€ì •í•˜ê¸° ìœ„í•´ì„œëŠ” <u>ê·¸ ì „ ë…¸ë“œë¥¼ ê¸°ì–µ</u>í•´ ë‘ì–´ì•¼ í•˜ë¯€ë¡œ (ê·¸ ì „ ë…¸ë“œì˜ nextê°€ í˜„ì¬ ê²€ì‚¬í•˜ê³  ìˆëŠ” ë…¸ë“œ), ì´ë¥¼ <u>ì €ì¥í•  í•œ ë³€ìˆ˜</u>ê°€ í•„ìš”í•˜**ë‹¤.     
ë˜í•œ, **<u>í•œ `level`ì´ ëë‚  ë•Œë§ˆë‹¤ì˜ ë§ˆì§€ë§‰ ë…¸ë“œ</u>ëŠ” `next`ë¥¼ ì§€ì •í•´ ì£¼ì§€ ì•Šì•„ë„ ë˜ë¯€ë¡œ, <u>ì´ë¥¼ êµ¬ë¶„í•  ì§€í‘œ</u> ì—­ì‹œ í•„ìš”**í•¨.            

ì¼ë‹¨, ê·¸ ì „ ë…¸ë“œë¥¼ ì €ì¥í•  ë³€ìˆ˜ë¥¼ ë‚˜ëŠ” **`before_node`ë¡œ ë§Œë“¤ì—ˆê³ , ì²˜ìŒì—ëŠ” `None`ìœ¼ë¡œ ì´ˆê¸°í™”** í•´ì£¼ì—ˆë‹¤.      
(ì²˜ìŒì—ëŠ” ê·¸ ì „ ë…¸ë“œë¼ê³  í•  ê²Œ ì—†ìœ¼ë‹ˆê¹Œ. ê·¸ë¦¬ê³  ì´ë¥¼ **`None`ìœ¼ë¡œ ì´ˆê¸°í™” í•´ì¤˜ì•¼ ë‚˜ì¤‘ì— ë¬¸ì œê°€ ìƒê¸°ì§€ ì•ŠëŠ”ë‹¤!** ì´ ê²ƒ ë•Œë¬¸ì— ì• ë¨¹ì€..ğŸ˜¶â€ğŸŒ«ï¸ **<u>ì´ˆê¸°í™”ì˜ ì¤‘ìš”ì„±</u>**ì„ ëŠê¼ˆìŒ.)

ë‹¤ìŒìœ¼ë¡œ **`level` ë§ˆì§€ë§‰ ë…¸ë“œ êµ¬ë³„ ì§€í‘œëŠ” ë¬¸ì œì—ì„œ ë³´ê¸° ì‰½ê²Œ í‘œí˜„ë˜ì–´ ìˆëŠ”. "`#`"ë¡œ í‘œê¸°**í•˜ê¸°ë¡œ í–ˆë‹¤.              
ì¦‰, ë§Œì•½ **í•´ë‹¹ íƒìƒ‰í•˜ê³  ìˆëŠ” ë…¸ë“œê°€ `level`ì˜ ë§ˆì§€ë§‰ ë…¸ë“œë¼ë©´, <u>`queue`ì—ì„œ ì´ ë‹¤ìŒì— `#`</u>ì„ ë„£ì–´ì£¼ê³ , ì´ë¥¼ `queue`ì—ì„œ êº¼ë‚´ ì½ì„ ë•Œì— <u>`before_node`ë„ ë‹¤ì‹œ `None`ìœ¼ë¡œ ì´ˆê¸°í™”</u>**í•´ì£¼ë©´ ë˜ê² ì§€.     
êµ³ì´ `next`ë¥¼ ì§€ì • ì•ˆ í•´ë„ ë˜ë¯€ë¡œ **<u>`continue`</u>ê¹Œì§€ ë„£ì–´ì£¼ë©´ ì™„ë²½ ê·¸ ìì²´ - â™¡**       

ê·¸ëŸ¼ ë‹¤ì‹œ ëŒì•„ì™€ì„œ, ì°¨ê·¼ì°¨ê·¼ ì½”ë“œë¥¼ ì§œ ë³´ì.     

ì¼ë‹¨ `root`ê°€ ì¡´ì¬í•œë‹¤ë©´, `queue`ë¥¼ ìƒì„±í•˜ê³  `root`, ë°”ë¡œ `level`ì´ ëë‚˜ë¯€ë¡œ `#` ê¹Œì§€ ë„£ì–´ì¤€ë‹¤.    
ê·¸ë¦¬ê³  `before_node`ëŠ” `None`ìœ¼ë¡œ ì´ˆê¸°í™”!      

```python
queue = deque([root, "#"])
before_node = None    
```

ì´ì œ **`bfs`ë¡œ treeë¥¼ ìˆœíšŒí•˜ë©° nextë¥¼ ì§€ì •**í•´ ì£¼ë©´ ë˜ê² ì§€!        
ìì„¸í•œ ì½”ë“œ ì„¤ëª…ê³¼ ë°©ë²•ì€ ì•„ë˜ ì½”ë“œì˜ ì£¼ì„ì„ ì°¸ê³ í•˜ì ğŸŒ                     

```python
while queue:
	# queueì— ìˆëŠ” ê°’ë“¤ì„ ë¨¼ì € ë“¤ì–´ê°„ ìˆœìœ¼ë¡œ êº¼ë‚´ê¸° 
	# ì „í˜•ì ì¸ BFS ìˆœíšŒ
	current = queue.popleft()
	
	# ë§ˆì§€ë§‰ì— treeë¥¼ ë‹¤ ëŒì•˜ì„ ë•Œ ê³„ì† "#"ë§Œ ìŒ“ì´ê²Œ ë˜ëŠ” ê²ƒì„ ë°©ì§€
	# ë§Œì•½ queueì— ê°’ì„ ë¹¼ëƒˆëŠ”ë°, queueì— ì•„ë¬´ê²ƒë„ ë‚¨ì•„ìˆì§€ ì•Šë‹¤ë©´ treeë¥¼ ë‹¤ ìˆœíšŒí•œ ê²ƒì´ë¯€ë¡œ
	# break
	if not queue:
		break

	# ë§Œì•½ í˜„ì¬ ëº€ ê°’ì´ "#"ì´ë¼ë©´ level ì „í™˜
	# ë”°ë¼ì„œ before_node ì´ˆê¸°í™” í›„, continue
	if current == "#":
		before_node = None
		queue.append("#")
		continue

	# ë§Œì•½ before_nodeê°€ ì¡´ì¬í•œë‹¤ë©´ next ê°’ì„ ì§€ì •í•  ìˆ˜ ìˆëŠ” ê°’ì´ ì¡´ì¬í•œë‹¤ëŠ” ì†Œë¦¬ì´ë¯€ë¡œ
	# ì§€ì •í•´ì£¼ë©´ ë¨        
	if before_node:
		before_node.next = current
   
   # ë‹¤ìŒ ê°’ì„ ìœ„í•´ before_nodeë¥¼ currentë¡œ!        
	before_node = current
	
	# ë§Œì•½ ì§€ê¸ˆ ë³´ëŠ” ë…¸ë“œì˜ ì™¼ìª½ì´ë‚˜ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œê°€ ì—†ë‹¤ë©´ êµ³ì´ appendí•  í•„ìš” ì—†ìœ¼ë¯€ë¡œ(perfect binary treeë‹ˆê¹Œ)
	# continue       
	if not current.left or not current.right:
		continue
   
	# ìì‹ ë…¸ë“œë“¤ queueì— append
	# ì „í˜•ì ì¸ BFS        
	queue.append(current.left)
	queue.append(current.right)
```

ë§ˆì§€ë§‰ìœ¼ë¡œ nextë¥¼ ëª¨ë‘ ì—…ë°ì´íŠ¸ í•œ rootë¥¼ returní•˜ë©´ ë!            

```python
return root
```   
     
### âœï¸ Final Code of First Thought

   ```python
from _collections import deque 

class Solution(object):
    def connect(self, root):
        if not root:
            return root

        queue = deque([root, "#"])
        before_node = None

        while queue:
            current = queue.popleft()
            
            if not queue:
                break

            if current == "#":
                before_node = None
                queue.append("#")
                continue
            
            if before_node:
                before_node.next = current
            
            before_node = current
            
            if not current.left or not current.right:
                continue
            
            queue.append(current.left)
            queue.append(current.right)
                
        return root
   ```
 
### âœï¸ Second Thought Solution(Explanation) 

ìœ„ì²˜ëŸ¼ ìŠ¤ìŠ¤ë¡œ í‘¼ í›„, discussionì„ í™•ì¸í•´ ë´¤ëŠ”ë°.. ì½”ë“œ ì™œì¼€ ì§§ì€ ê²ƒì´ë‹ˆ..ğŸ˜­     
í‘..     

â†’ ë„ˆë¬´ ì–´ë ¤ì›Œ..ğŸ˜­ ì„¤ëª… ë“¤ì–´ì•¼ í• ë“¯..ì¶”í›„ì— ì™„ì„±í•˜ì!            

     
### âœï¸ Final Code of Second Thought

   ```python
class Solution(object):
    def connect(self, root):
        """
        :type root: TreeLinkNode
        :rtype: nothing
        """
        
        if not root:
            return None
        cur  = root
        next = root.left

        while cur.left :
            cur.left.next = cur.right
            if cur.next:
                cur.right.next = cur.next.left
                cur = cur.next
            else:
                cur = next
                next = cur.left
   ```
 
    	    
<div class="notice--primary" markdown="1">
ğŸŒŸ <strong>[6ì£¼ì°¨] myown_1ì˜ <u>í¬ì¸íŠ¸</u></strong>    

- BFS     
- queue      
     
</div>
