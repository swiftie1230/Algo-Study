# [6ì£¼ì°¨] ì•Œê³ ë¦¬ì¦˜ my own ë‘ ë²ˆì§¸ ë¬¸ì œ

## ğŸ’¬ [Delete Nodes And Return Forest](https://leetcode.com/problems/delete-nodes-and-return-forest/) 

### ğŸ“„ ë¬¸ì œ ì„¤ëª…  

Given the `root` of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in `to_delete`, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest. You may return the result in any order.

### â›”ï¸ ì œí•œì‚¬í•­
- The number of nodes in the given tree is at most `1000`.
- Each node has a distinct value between `1` and `1000`.
- `to_delete.length <= 1000`
- `to_delete` contains distinct values between `1` and `1000`.

### ğŸ’­ ì…ì¶œë ¥ ì˜ˆ

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #1</u>     

<img width="240" alt="Screen Shot 2022-03-25 at 8 59 29 PM" src="https://user-images.githubusercontent.com/63195670/160116877-57ccd9f3-df0f-4313-b237-dda7b37dd674.png">     

[ì…ë ¥]   

   ```python
root = [1,2,3,4,5,6,7], to_delete = [3,5]
   ```             
      
    
[ì¶œë ¥]    

   ```python    
[[1,2,null,4],[6],[7]]      
   ```
</div>   


<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #2</u>         

[ì…ë ¥]   

   ```python
root = [1,2,4,null,3], to_delete = [3]   
   ```             
      
    
[ì¶œë ¥]    

   ```python    
[[1,2,4]]      
   ```
   
</div>   
  

### âœï¸ Question Clarifying & Time, Space Complexity 

   ```python
'''
const template = {
  firstStep: {
    I: root of a binary tree, to delete -> node to delete, 
    O: forest (a disjoint union of trees), 
    C: The number of nodes in the given tree is at most 1000, Each node has a distinct value between 1 and 1000, to_delete.length <= 1000, to_delete contains distinct values between 1 and 1000.,
    E: ê¸¸ì´ê°€ 0ì¸ treeëŠ” ê·¸ëŒ€ë¡œ ë¦¬í„´
  },
  secondStep: {
    DS: 'DFS? -> ìì‹ ë¶€ëª¨ ê´€ê³„ë¡œ ì‚­ì œí•´ì•¼ í•˜ë¯€ë¡œ',
    Alg: 'ì‚­ì œí•´ì„œ ë¶„ë¦¬ë˜ë©´ ë”°ë¡œ ê°€ë¦¬í‚¤ëŠ” ë…¸ë“œ ì €ì¥! -> ì§ì ‘ ì‚­ì œí•˜ë©´ ëª¨ë“  ë…¸ë“œë“¤ì„ ëŒ ìˆ˜ ì—†ëŠ” ë¶ˆìƒì‚¬ê°€ ìƒê¹€ : current_nodeì˜ ì£¼ì†Œë¥¼ ì•Œê³  ìˆìœ¼ë¯€ë¡œ êµ³ì´ X',
    bruteForce: solution = () => {
        // pseudo code
        def delNodes(self, root, to_delete):
            if not root:
                return root
        
            self.answer = [root]
        
            self.dfs(root, to_delete, 0, 0, None)

            return self.answer
        
        
        def dfs(self, current_node, to_delete, left, right, before_node):
            
            if not current_node:
                return
            
            # í˜„ì¬ ë…¸ë“œ deleteí•´ì•¼ í•  ë•Œ
            if current_node.val in to_delete:
                # ë§Œì•½ answerì— ìˆë‹¤ë©´ ì‚¬ë¼ì ¸ì•¼ í•˜ë‹ˆê¹Œ ì§€ì›Œì¤˜ì•¼í•¨ -> ìµœì•…ì˜ ê²½ìš° O(N)
                if current_node in self.answer:
                    remove(current_node)

                # current_node ì™¼ìª½ answerì— append -> ë–¨ì–´ì§„ tree
                if current_node.left:
                    append(current_node.left)
                # current_node ì˜¤ë¥¸ìª½ answerì— append -> ë–¨ì–´ì§„ tree
                if current_node.right:
                    self.answer.append(current_node.right)
                
                # ì „ ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ì´ì—ˆëŠ”ì§€ ì™¼ìª½ì´ì—ˆëŠ”ì§€ í™•ì¸í•˜ê³  ì–´ëŠìª½ì„ Noneìœ¼ë¡œ ë°”ê¿€ì§€! -> ì˜ë¼ë‚´ëŠ” ê±°ì„
                if left == 1:
                    before_node.left = None
                elif right == 1:
                    before_node.right = None
                    
            # ì˜ë¼ëƒˆë‹¤ê³  current_nodeì˜ ì£¼ì†Œë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šì€ ê²Œ ì•„ë‹ˆë¯€ë¡œ current_nodeì˜ ì™¼ìª½, ì˜¤ë¥¸ìª½ ê·¸ëŒ€ë¡œ ê²€ì‚¬ ê°€ëŠ¥!!
            self.dfs(current_node.left, to_delete, 1, 0, current_node)
            self.dfs(current_node.right, to_delete, 0, 1, current_node)
            
            
            
    }
    time: O(N*N) : Nê°œì˜ ë…¸ë“œê°€ ìˆê³ , answerì— ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê³¼ì •,
    space: O(N) : ìµœì•…ì˜ ê²½ìš° í•˜ë‚˜ë„ deleteí•˜ì§€ ì•Šì„ ìˆ˜ ìˆê¸°ì—
  },
    thirdStep: {
    DS: '-',
    Alg: '-',
    bruteForce: solution = () => {
        // pseudo code
        -

    }
    time: -,
    space: -
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ í™•ì¸í•˜ì!
    }
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ í™•ì¸í•˜ì!
    }
  },
  fifthStep: {
    testCases: (givenInput, expectedOutput, func) => {

      const result = func(givenInput)
      if(result === expectedOutput) {
         println(`SUCCESS(O)`)
      } else {
         println(`FAILED(X)`)
      }
      
    }
    SUCCESS! ì„±ê³µ
  }
}
'''
   ```

### âœï¸ First Thought Solution(Explanation) 

ì´ ë¬¸ì œì—ì„œëŠ” **<u>ìì‹ ë¶€ëª¨ ê´€ê³„</u>ë¥¼ ì•Œì•„ì•¼ í•˜ê³ , ë§Œì•½ ì‚­ì œí•´ì•¼ í•˜ëŠ” ë…¸ë“œë¥¼ ì°¾ëŠ”ë‹¤ë©´ ë¶€ëª¨ì™€ ìì‹ì„ ëŠì–´ì•¼ í•˜ë¯€ë¡œ <u>DFS ë°©ì‹</u>ì„ ì‚¬ìš©í•˜ëŠ” ê²Œ ë§ë‹¤**ê³  ìƒê°í–ˆë‹¤.     
ë˜í•œ ë¬¸ì œë¥¼ í’€ë‹¤ê°€ ë…¸ë“œë¥¼ ë¶„ë¦¬í•˜ë©´ ê³„ì† ì´ì–´ì„œ ìˆœíšŒí•  ìˆ˜ ì—†ìœ¼ë‹ˆ ë”°ë¡œ ë¶„ë¦¬ëœ ì´í›„ì˜ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” ë³€ìˆ˜ë¥¼ ë‘ì–´ì•¼ í•œë‹¤ê³  ìƒê°í–ˆëŠ”ë°, ì½”ë“œë¥¼ ìì„¸íˆ ëœ¯ì–´ë³¸ ê²°ê³¼ `current_node`ë¼ê³  ëª…ì‹œë˜ì–´ ìˆëŠ” ë…¸ë“œê¸°ì— êµ³ì´ ê·¸ëŸ´ í•„ìš”ê°€ ì—†ë‹¤ëŠ” ê²ƒë„ ì•Œê²Œ ë˜ì—ˆìŒ!        

í£ ğŸ‘€ ì´ë ‡ê²Œ ì„¸ì„¸í•œ ë¬¸ì œë¥¼ í‘¸ëŠ” ê³¼ì •ì—ì„œ ëŠê¼ˆë˜ ì˜¤ë¥˜ì™€ í•´ê²° ë°©ë²•ë„ ì ì–´ë†“ëŠ” ê²Œ ë§ë‹¤ê³  ìƒê°í•´ì„œ ì ì–´ë†“ìœ¼ë ¤ í•˜ëŠ” ì¤‘ â°            

ì¼ë‹¨ ì£¼ì–´ì§„ ì¡°ê±´ëŒ€ë¡œ í•¨ìˆ˜ ì„ ì–¸ ë¨¼ì € í•´ë³´ì.

```python
class Solution(object):
    def delNodes(self, root, to_delete):
```     

ë§Œì•½ ì…ë ¥ìœ¼ë¡œ ë“¤ì–´ì˜¨ `root`ë‚˜ `to_delete`ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ `root` ê·¸ëŒ€ë¡œ ë¦¬í„´!           

```python
if not root or not to_delete:
	return root
```

ê·¸ë¦¬ê³  ë¦¬í„´í•  ê°’ì¸ `self.answer`ë¥¼ ì„ ì–¸í•˜ê³  `root`ë¥¼ ë„£ì€ ì±„ë¡œ ì´ˆê¸°í™”í•˜ê¸°.      

ë‹¤ìŒìœ¼ë¡œëŠ” `dfs`ë¥¼ ëŒë¦¬ê³ , ì´ `dfs`ë¥¼ ìˆ˜í–‰í•˜ë©° `answer`ë¥¼ ë¬¸ì œ ì¡°ê±´ì— ë§ê²Œ ì±„í›ˆ í›„, `return` í•´ì£¼ë©´ ë˜ê² ì§€?    

```python
self.answer = [root]

self.dfs(root, to_delete, 0, 0, None)

return self.answer
```

ì°¨ê·¼ì°¨ê·¼í•˜ë©´ ì–´ë µì§€ ì•Šë‹¤! ì„œì§„ì•„, ë„Œ í•  ìˆ˜ ìˆì–´..í•  ìˆ˜ ìˆ..ì–´..? ğŸ¤¦ğŸ»â€â™€ï¸         
..ì´ì œ dfs í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ë³´ì.       

```python
def dfs(self, current_node, to_delete, left, right, before_node):     
```

ì¼ë‹¨ íŒŒë¼ë¯¸í„°ë¶€í„° í•˜ë‚˜í•˜ë‚˜ ì„¤ëª…í•´ë³´ìë©´, **`current_node`ëŠ” ë­ ëª¨ë“  `dfs`ì—ì„œì²˜ëŸ¼ í˜„ì¬ ê²€ì‚¬í•˜ê³  ìˆëŠ” ë…¸ë“œë¥¼ ì˜ë¯¸, `to_delete`ëŠ” ë¬¸ì œ ì¡°ê±´ì—ì„œì²˜ëŸ¼ ì‚­ì œí•˜ê³  ì‹¶ì€ ë…¸ë“œë“¤ ë¦¬ìŠ¤íŠ¸ ê·¸ëŒ€ë¡œ**.     

ë‚˜ë¨¸ì§€ê°€ ìƒˆë¡œìš´ë°, **`left`ì™€ `right`ëŠ” ì´ ë…¸ë“œê°€ ìœ„ ë…¸ë“œ(ë¶€ëª¨ ë…¸ë“œ)ì˜ `left` ìì‹ ë…¸ë“œì¸ì§€, `right` ìì‹ ë…¸ë“œì¸ì§€ë¥¼ êµ¬ë¶„í•˜ê¸° ìœ„í•´** ë§Œë“¤ì–´ ë†“ì•˜ë‹¤.   
ë§Œì•½ `left` ìì‹ ë…¸ë“œë¼ë©´ `left`íŒŒë¼ë¯¸í„° ê°’ì„ 1, `right` ìì‹ ë…¸ë“œë¼ë©´ `right` íŒŒë¼ë¯¸í„° ê°’ì„ 1ë¡œ í•˜ëŠ” ê²ƒ!       
ë˜í•œ í˜„ì¬ **`current_node`ê°€ `delete`í•´ì•¼ í•  ê°’ì´ë¼ë©´ ë¶€ëª¨ ë…¸ë“œì—ì„œ ì—°ê²°ì„ ëŠì–´ì•¼ í•˜ë¯€ë¡œ ë¶€ëª¨ ë…¸ë“œë¥¼ ì €ì¥í•  `before_node`ë¼ëŠ” íŒŒë¼ë¯¸í„°**ë„ ë§Œë“¤ì—ˆë‹¤.       

ì´ì œ ì§„ì§œ ì‘ì„±í•´ë³´ë©´, `end clause`ë¡œ ë§Œì•½ í˜„ì¬ ê²€ì‚¬í•˜ëŠ” ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œ `return`.              
 
   ```python
if not current_node:
	return
   ```

ë‹¤ìŒìœ¼ë¡œ, í˜„ì¬ ê²€ì‚¬í•˜ê³  ìˆëŠ” ë…¸ë“œì˜ `value`ê°€ `to_delete`ì— í¬í•¨ë˜ì–´ ìˆì„ ê²½ìš°ì— ëŒ€í•´ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ê² ì§€.     
ë§Œì•½ ì´ ë…¸ë“œê°€ `answer`ì— í¬í•¨ë˜ì–´ ìˆëŠ” ê²½ìš°ë„¤ëŠ” ì´ê±¸ `answer`ì—ì„œ ì œê±°í•´ ì£¼ì–´ì•¼ í•¨.    

   ```python
if current_node in self.answer4:
	self.answer.remove(current_node)
   ```

ê·¸ë¦¬ê³  ì´ ë…¸ë“œì˜ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì˜ ìì‹ ë…¸ë“œê°€ ê°ê° ì¡´ì¬í•  ê²½ìš°, ì´ë¥¼ `answer`ì— ë”°ë¡œ `append` í•´ì£¼ì. í˜„ì¬ ë…¸ë“œê°€ ì‚­ì œë˜ì–´ ê¸°ì¡´ `tree`ì—ì„œ ë¶„ë¦¬ëœ `tree`ë¥¼ ë„£ì–´ì¤€ë‹¤ê³  ë³´ë©´ ëœë‹¤.         

```python
if current_node.left:
	self.answer.append(current_node.left)

if current_node.right:
	self.answer.append(current_node.right)
```

ì´ë ‡ê²Œ ë¶„ë¦¬í•˜ê¸° ì „, ë¶„ë¦¬ë  ë‚˜ë¨¸ì§€ ë¶€ë¶„ë“¤ì„ ì €ì¥í•˜ëŠ” ê²ƒì„ ë§ˆì³¤ë‹¤ë©´, ë³¸ê²©ì ìœ¼ë¡œ ë¶„ë¦¬ í›„ ì´ì–´ì„œ ìˆœíšŒí•˜ëŠ” ì¼ë§Œ ë‚¨ì€ ê²ƒ. 

ë§Œì•½ í˜„ì¬ ê²€ì‚¬í•˜ê³  ìˆëŠ” ë…¸ë“œê°€ ë¶€ëª¨ ë…¸ë“œì˜ ì™¼ìª½ ìì‹ ë…¸ë“œì˜€ë‹¤ë©´ ë¶€ëª¨ ë…¸ë“œ(`before_node`)ì˜ ì™¼ìª½ ìì‹ ë…¸ë“œë¥¼ `None`ìœ¼ë¡œ ë°”ê¾¸ê³ , ì•„ë‹ˆë¼ë©´ ë°˜ëŒ€ë¥¼ ë°”ê¾¸ë©´ ë¨.            

```python
if left == 1:
	before_node.left = None
elif right == 1:
	before_node.right = None
```

ê·¸ë¦¬ê³  current_nodeì˜ ìì‹ ë…¸ë“œë“¤ì„ ì´ì–´ì„œ ìˆœíšŒí•˜ë©´ dfs í•¨ìˆ˜ ì‘ì„±ë„ ë!    

```python
self.dfs(current_node.left, to_delete, 1, 0, current_node)
self.dfs(current_node.right, to_delete, 0, 1, current_node)
```


### âœï¸ Final Code of First Thought

   ```python
class Solution(object):
    def delNodes(self, root, to_delete):
        if not root:
            return root
        
        if not to_delete:
            return root
        
        self.answer = [root]
        
        self.dfs(root, to_delete, 0, 0, None)

        return self.answer
        

        
    def dfs(self, current_node, to_delete, left, right, before_node):
        
        if not current_node:
            return
        
        
        if current_node.val in to_delete:
            
            if current_node in self.answer:
                self.answer.remove(current_node)
        
            if current_node.left:
                self.answer.append(current_node.left)
            if current_node.right:
                self.answer.append(current_node.right)
            
            if left == 1:
                before_node.left = None
            elif right == 1:
                before_node.right = None
                
        
        self.dfs(current_node.left, to_delete, 1, 0, current_node)
        self.dfs(current_node.right, to_delete, 0, 1, current_node)  
   ```
 
### âœï¸ Second Thought Solution(Explanation) 

ì„¤ëª… ë“£ê³  ì‘ì„±í•˜ê¸°.      


### âœï¸ Final Code of Second Thought

   ```python
def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        queue = collections.deque([(root, False)])
        res = []
        deleteSet = set(to_delete)
        
        while queue:
            node, hasParent = queue.popleft()
            # new Root found
            if not hasParent and node.val not in to_delete:
                res.append(node)
                
            hasParent = not node.val in to_delete

            if node.left: 
                queue.append((node.left, hasParent))
                if node.left.val in to_delete:
                    node.left = None
            if node.right:
                queue.append((node.right, hasParent))
                if node.right.val in to_delete:
                    node.right = None
            
        return res
   ```     

  
   	    
<div class="notice--primary" markdown="1">
ğŸŒŸ <strong>[6ì£¼ì°¨] my_own_2ì˜ <u>í¬ì¸íŠ¸</u></strong>    

- ë‹¹ì—°íˆ ì¼ë‹¨.. DFS  
- ìƒˆë¡œìš´ í•¨ìˆ˜ê°€ í•„ìš”í•  ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡­ê²Œ ë§Œë“œëŠ” ê²ƒì„ ë‘ë ¤ì›Œí•˜ì§€ ë§ì! íŠ¹íˆ í•„ìš”í•œ íŒŒë¼ë¯¸í„°ë“¤ì€ ê³¼ê°í•˜ê²Œ ë„£ê¸°!        

     
</div>
