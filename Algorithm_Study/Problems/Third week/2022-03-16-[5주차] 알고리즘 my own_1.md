# [5ì£¼ì°¨] ì•Œê³ ë¦¬ì¦˜ my own ì²« ë²ˆì§¸ ë¬¸ì œ

## ğŸ’¬ [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) 

### ğŸ“„ ë¬¸ì œ ì„¤ëª…  

Given the `root` of a binary tree, *determine if it is a valid binary search tree (BST)*.

A **valid BST** is defined as follows:

- The left subtree of a node contains only nodes with keys **less than** the node's key.

- The right subtree of a node contains only nodes with keys **greater than** the node's key.

- Both the left and right subtrees must also be binary search trees.

### â›”ï¸ ì œí•œì‚¬í•­
- The number of nodes in the tree is in the range `[1, 10^4]`.
- `- 2^31 <= Node.val <= 2^31 - 1`

### ğŸ’­ ì…ì¶œë ¥ ì˜ˆ

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #1</u>     

<img width="329" alt="Screen Shot 2022-03-16 at 10 20 09 AM" src="https://user-images.githubusercontent.com/63195670/158497962-4cc4ce41-59df-4003-a736-fd72816de872.png">            

[ì…ë ¥]   

   ```python
root = [2, 1, 3]
   ```             
      
    
[ì¶œë ¥]    

   ```python    
true       
   ```
</div>   


<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #2</u>     

<img width="422" alt="Screen Shot 2022-03-16 at 10 20 23 AM" src="https://user-images.githubusercontent.com/63195670/158497967-5f1ef16a-37b9-43b6-ae78-066e212f31ca.png">     

[ì…ë ¥]   

   ```python
root = [5,1,4,null,null,3,6]
   ```             
      
    
[ì¶œë ¥]    

   ```python    
false     
   ```
   
</div>    
  

### âœï¸ Question Clarifying & Time, Space Complexity 


   ```python
'''
const template = {
  firstStep: {
    I: root of a binary tree, 
    O: boolean (determine if it is a valid binary search tree(BST)), 
    C: The number of nodes in the tree is in the range [1, 104](ë…¸ë“œ ì ì–´ë„ 1ê°œ! ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš°ëŠ” ì—†ë‹¤), -231 <= Node.val <= 231 - 1,
    E: ê¸¸ì´ê°€ 1 -> return true
  },
  secondStep: {
    DS: 'DFS',
    Alg: 'inorder ìˆœ(ì™¼ìª½ ìì‹ ë…¸ë“œ -> ë¶€ëª¨ ë…¸ë“œ -> ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ)ìœ¼ë¡œ arrayì— ë„£ì–´ì£¼ë©´ valid binary search treeë¼ë©´ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ì´ ë  ê²ƒ',
    bruteForce: solution = () => {
        // pseudo code
        class Solution(object):
            def isValidBST(self, root):

              array = []
                
                
              dfs(root)

              for element in array:
                before element >= next element:
                  return False

              return True
            def dfs(self, currentNode):

              if !currentNode:
                return
              
              self.dfs(left)
              array.append(currentNode)
              self.dfs(right)
    }
    time: O(N + N) : ê° ë…¸ë“œë¥¼ ëŒê³ , array ë˜í•œ ëˆë‹¤,
    space: O(logN) : ë…¸ë“œì˜ ê¹Šì´ê¹Œì§€ recursion(dfs)
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ í™•ì¸í•˜ì!
    }
  },
  fifthStep: {
    testCases: (givenInput, expectedOutput, func) => {

      const result = func(givenInput)
      if(result === expectedOutput) {
         println(`SUCCESS(O)`)
      } else {
         println(`FAILED(X)`)
      }
      
    }
    SUCCESS! ì„±ê³µ
  }
}
'''
   ```

### âœï¸ First Thought Solution(Explanation) 

ì°¬ì°¬íˆ ê³ ë¯¼í•´ë³´ë©´ ì•„ì´ë””ì–´ë¥¼ ìƒê°í•´ ë‚´ëŠ” ê²ƒì€ ê·¸ë ‡ê²Œ ì–´ë µì§€ ì•Šë‹¤.  
But..ê²°êµ­ í•´ê²°ë°©ë²•ì„ ì°¾ì§€ ëª»í•˜ê³  ì„£ë¶ˆë¦¬ Discussion íŒíŠ¸ë¥¼ ë³´ì•˜ë˜ ë¬¸ì œ..ğŸ˜­    
ì°¬ì°¬íˆ ë‹¤ì‹œ ìƒê°í•´ë³´ë©´ ì˜¨ì „íˆ ë‚´ í˜ìœ¼ë¡œ í’€ ìˆ˜ ìˆì—ˆì„ í…ë°, í•˜ëŠ” ì•„ì‰¬ì›€ë„ ë“¤ì§€ë§Œ..ê¼¼ê¼¼íˆ ì§šê³  ë„˜ì–´ê°€ì! ê·¸ë˜ì•¼ ë¹„ìŠ·í•œ ì•„ì´ë””ì–´ì˜ ë¬¸ì œê°€ ë‚˜ì™”ì„ ë•Œ í™•ì‹ ì„ ê°€ì§€ê³  ë°”ë¡œ í’€ ìˆ˜ ìˆìœ¼ë‹ˆ! o(ï½€Ï‰Â´ )o            

ì´ ë¬¸ì œì˜ í•µì‹¬ì€, **ì´ íŠ¸ë¦¬ì˜ ë…¸ë“œë“¤ì„ <u>in-order ë°©ì‹ìœ¼ë¡œ traversing</u> í–ˆì„ ë•Œ, <u>ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ë˜ì–´ ê°’ë“¤ì´ ì¶œë ¥ëœë‹¤</u>ëŠ” ê²ƒ!**           

ê·¸ë ‡ê¸°ì— ì´ ê°’ë“¤ì„ **<u>in-order traversing  ë°©ì‹</u> ê·¸ëŒ€ë¡œ arrayì— append**í•´ì¤€ í›„, ì´ **arrayë¥¼ ëŒë©´ì„œ <u>ë§Œì•½ ì •ë ¬ë˜ì–´ ìˆì§€ ì•Šì€ ê°’ì´ ì¡´ì¬</u>í•œë‹¤ë©´ <u>`False`ë¥¼ ë¦¬í„´</u>**í•´ì£¼ë©´ ëœë‹¤ ğŸŒ    

```python
class Solution(object):
    def isValidBST(self, root):
```   

ì¼ë‹¨ ë…¸ë“œì˜ ê°’ë“¤ì„ `in-order` ë°©ì‹ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ `append`í•  `list` `array`ë¥¼ ì„ ì–¸í•˜ê³  ì´ˆê¸°í™”í•´ì£¼ì.      

```python
self.array = []
```

ë‹¤ìŒìœ¼ë¡œ `in-order` ë°©ì‹ìœ¼ë¡œ `traversing`í•  í•¨ìˆ˜ `dfs`ë¥¼ ë§Œë“¤ì–´ì£¼ì.    
ì•„ëŠ” ë°©ì‹ ê·¸ëŒ€ë¡œ ë§Œë“¤ì–´ì£¼ë©´ ëœë‹¤! **<u>`end clause`</u> ì¤‘ í•˜ë‚˜ë¡œ, ë§Œì•½ <u>í˜„ì¬ ë³´ê³  ìˆëŠ” ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ `return`</u> í•´ì£¼ê³ , <u>`left`, `currentNode`, `right` ë°©ì‹ìœ¼ë¡œ ìˆœíšŒ</u>í•˜ë˜, <u>`currentNode`ëŠ” `append`</u>í•´ì£¼ë©´ ë!**    

```python
def dfs(self, currentNode):
	
	# end clause
	if not currentNode:
		return
	
	self.dfs(currentNode.left)
	self.array.append(currentNode.val)
	self.dfs(currentNode.right)
```

ì´ì œ ì›ë˜ í•¨ìˆ˜ `isValidBST`ë¡œ ëŒì•„ì™€ì„œ, `array`ë¥¼ ëŒë©° ë§Œì•½ ì •ë ¬ì´ ë˜ì–´ ìˆì§€ ì•Šì€, ì¦‰, ë’¤ì— ìˆëŠ” ìˆ˜ê°€ ë” ì‘ì€ ê²½ìš°ê°€ ì¡´ì¬í•˜ë©´ ë°”ë¡œ `False` ë°˜í™˜, ëê¹Œì§€ ëŒì•˜ëŠ”ë°ë„ ëª¨ë‘ ì •ë ¬ë˜ì–´ ìˆë‹¤ë©´ `True`ë¥¼ ë°˜í™˜í•œë‹¤.    

```python
for i in range(1, len(self.array)):
	if self.array[i-1] >= self.array[i]:
		return False
            
return True
```

     
### âœï¸ Final Code of First Thought

   ```python
class Solution(object):
    def isValidBST(self, root):
        
        self.array = []
        self.dfs(root)
        
        for i in range(1, len(self.array)):
            if self.array[i-1] >= self.array[i]:
                return False
            
        return True
        
    def dfs(self, currentNode):

        if not currentNode:
            return
        
        self.dfs(currentNode.left)
        self.array.append(currentNode.val)
        self.dfs(currentNode.right)
   ```
 
    	    
<div class="notice--primary" markdown="1">
ğŸŒŸ <strong>[5ì£¼ì°¨] myown_1ì˜ <u>í¬ì¸íŠ¸</u></strong>    

- ë‹¹ì—°íˆ ì¼ë‹¨.. DFS     
- Inorderë¥¼ ì‚¬ìš©í•˜ëŠ” ì•„ì´ë””ì–´..      
     
</div>
