# [5ì£¼ì°¨] ì•Œê³ ë¦¬ì¦˜ my own ë‘ ë²ˆì§¸ ë¬¸ì œ

## ğŸ’¬ [Clone Graph](https://leetcode.com/problems/clone-graph/) 

### ğŸ“„ ë¬¸ì œ ì„¤ëª…  

Given a reference of a node in a **connected** undirected graph.

Return a **deep copy** (clone) of the graph.

Each node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.

```python
class Node {
    public int val;
    public List<Node> neighbors;
}
```

#### ğŸ—’ **Test case format:**

For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.

**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

The given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.

### â›”ï¸ ì œí•œì‚¬í•­
- The number of nodes in the graph is in the range `[0, 100]`.
- `1 <= Node.val <= 100`
- `Node.val` is unique for each node.
- There are no repeated edges and no self-loops in the graph.
- The Graph is connected and all nodes can be visited starting from the given node.

### ğŸ’­ ì…ì¶œë ¥ ì˜ˆ

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #1</u>     

<img width="371" alt="Screen Shot 2022-03-18 at 5 44 03 PM" src="https://user-images.githubusercontent.com/63195670/158966611-ee09646e-765a-421c-b8eb-3ee2392b100c.png">            

[ì…ë ¥]   

   ```python
adjList = [[2,4],[1,3],[2,4],[1,3]] 
   ```             
      
    
[ì¶œë ¥]    

   ```python    
[[2,4],[1,3],[2,4],[1,3]]      
   ```
</div>   


<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #2</u>     

<img width="161" alt="Screen Shot 2022-03-18 at 5 45 50 PM" src="https://user-images.githubusercontent.com/63195670/158966787-a17b8d90-9b45-473e-ba99-73842a000ab9.png">     

[ì…ë ¥]   

   ```python
adjList = [[]]
   ```             
      
    
[ì¶œë ¥]    

   ```python    
[[]]     
   ```
   
</div>    

<div class="notice--primary" markdown="1">
ğŸŒ <u>ì…ì¶œë ¥ ì˜ˆ #3</u>       

[ì…ë ¥]   

   ```python
adjList = []
   ```             
      
    
[ì¶œë ¥]    

   ```python    
[]     
   ```
   
</div>    


### âœï¸ Question Clarifying & Time, Space Complexity 


   ```python
'''
const template = {
  firstStep: {
    I: Node -> reference of a node in a connected undirected graph , 
    O: Node -> deep copy(clone) of the graph, 
    C: The number of nodes in the graph is in the range [0, 100], 1 <= Node.val <= 100, Node.val is unique for each node,
       There are no repeated edges and no self-loops in the graph, The Graph is connected and all nodes can be visited starting from the given node,
    E: ê¸¸ì´ê°€ 1 -> return true
  },
  secondStep: {
    DS: 'DFS',
    Alg: 'visitedì—ëŠ” ë°©ë¬¸ì„ í‘œì‹œ, mì€ ë…¸ë“œë¥¼ ê·¸ë ¸ë‹¤(ìƒì„±í–ˆë‹¤) í‘œì‹œ ->  ìƒˆë¡œìš´ ê·¸ë˜í”„ë¥¼ ë§Œë“¤ê³ , ì´ë¥¼ ë°˜í™˜í•œë‹¤',
    bruteForce: solution = () => {
        // pseudo code
        def cloneGraph(self, node):
            if not node:
                return node
            m, visited = dict(), set()
            self.dfs(node, m, visited)
            return m[node]

        def dfs(self, n, m, visited):
            if n in visited:
                return
            
            # ë°©ë¬¸í–ˆë‹¤ í‘œì‹œ 
            visited.add(n)
            
            # ìƒˆë¡œìš´ ë…¸ë“œ ë§Œë“¤ì–´ì£¼ê³ , neighborsë„ ì´ì–´ì¤€ë‹¤.
            if n not in m:
                m[n] = Node(n.val)
            
            for neigh in n.neighbors:
                if neigh not in m:
                    m[neigh] = Node(neigh.val)
                # neighborì„ addí•´ì£¼ê³ , neighborsë“¤ì— ëŒ€í•´ì„œë„ ë™ì¼í•˜ê²Œ ìˆ˜í–‰
                m[n].neighbors.append(m[neigh])
                self.dfs(neigh, m, visited)

    }
    time: O(N*N) : Nê°œì˜ ë…¸ë“œê°€ ìˆê³ , ëª¨ë‘ë¥¼ ëŒë©´ì„œ visitedë‚˜ mì— ìˆëŠ”ì§€ í™•ì¸í•˜ë¯€ë¡œ!,
    space: O(logN + N) : ë…¸ë“œì˜ ê¹Šì´ê¹Œì§€ recursion(dfs) = logN, ìƒˆë¡œìš´ ê·¸ë˜í”„ë¥¼ ë§Œë“ ë‹¤ = N
  },
  fourthStep: {
    actualSolution: () => {
      /// Actual Code
      ì•„ë˜ì—ì„œ í™•ì¸í•˜ì!
    }
  },
  fifthStep: {
    testCases: (givenInput, expectedOutput, func) => {

      const result = func(givenInput)
      if(result === expectedOutput) {
         println(`SUCCESS(O)`)
      } else {
         println(`FAILED(X)`)
      }
      
    }
    SUCCESS! ì„±ê³µ
  }
}
'''
   ```

### âœï¸ Solution(Explanation) 

ì´ ë¬¸ì œì˜ ì•„ì´ë””ì–´ëŠ” **ë°©ë¬¸í•œ ë…¸ë“œë“¤ê³¼, ìƒì„±í•œ ë…¸ë“œë“¤ì„ ê¸°ë¡í•˜ë©´ì„œ ê·¸ë˜í”„ë¥¼ ê¹Šê²Œ íƒìƒ‰í•˜ëŠ” ê²ƒ**ì— ìˆë‹¤! ì •í™•í•˜ê²Œ ë§í•˜ë©´, `dfs traverse`ëŠ” ê·¸ë˜ë„ ì „ì— ë³¸ ë¬¸ì œë“¤ë¡œ (ì–´ëŠì •ë„..) ì‰½ê²Œ í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ì´ë‹ˆ **<u>íƒìƒ‰í•˜ë©´ì„œ ë°©ë¬¸í•œ ë…¸ë“œ ë”°ë¡œ, ìƒì„±í•œ ë…¸ë“œ ë”°ë¡œ ê¸°ë¡</u>í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•¨** ğŸŒ        

<div class="notice--primary" markdown="1">
ğŸ™‹ğŸ»â€â™€ï¸ <strong><u>ì—¬ê¸°ì„œ ì ê¹!</u> <u>ë°©ë¬¸í•œ ë…¸ë“œì™€ ìƒì„±í•œ ë…¸ë“œë¥¼ ê¸°ë¡</u>í•˜ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ì¸ê°€ìš”? ë˜, <u>ë”°ë¡œ ê¸°ë¡</u>í•˜ëŠ” ì´ìœ ëŠ”?</strong>    

ğŸ“Œ <strong><u>ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ê¸°ë¡í•˜ëŠ” ì´ìœ </u></strong>    

ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ê¸°ë¡í•´ ë†“ì§€ ì•Šìœ¼ë©´ ì´ë¯¸ íƒìƒ‰ì„ ì™„ë£Œí•œ ë…¸ë“œë¥¼ ì¬íƒìƒ‰í•˜ëŠ”, ë¬´í•œë£¨í”„ì— ë¹ ì§ˆ ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤. íŠ¹íˆ, <strong>connected graph</strong>ì´ê¸° ë•Œë¬¸ì—..ì´ ë¬¸ì œì—ì„œëŠ” ë”ìš± ì¤‘ìš”í•¨!        

ğŸ“Œ <strong><u>ìƒì„±í•œ ë…¸ë“œë¥¼ ê¸°ë¡í•˜ëŠ” ì´ìœ </u></strong>    

ì´ ì—­ì‹œ ê°„ë‹¨í•˜ë‹¤. ìƒì„±í•œ ë…¸ë“œë¥¼ ê¸°ë¡í•´ ë†“ì§€ ì•Šìœ¼ë©´ ì´ë¯¸ ìƒì„±í•œ ë…¸ë“œë¥¼ ì¬ìƒì„±í•´ ë²„ë¦¬ê²Œ ë˜ëŠ” ê¼´ì´ ë˜ì–´ ë²„ë¦¬ê¸° ë•Œë¬¸! íŠ¹íˆ, ê·¸ ì „ì— <code>neighbors</code>ì— í¬í•¨ëœ ë…¸ë“œë¡œ ìƒì„±í•´ ë†“ì•˜ëŠ”ë° ì´ë¥¼ ì¬ìƒì„±í•˜ê²Œ ë˜ë©´, ì—°ê²°ëœ ê·¸ë˜í”„ë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ê°€ ì—†ê² ì§€!     

ë˜í•œ <strong><u>ìì‹ ë…¸ë“œë“¤ê³¼ ì—°ê²°í•  ë•Œ, ì´ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¬ ë°©ë²•ì´ ì—†ìœ¼ë¯€ë¡œ</u>, ê¸°ì¡´ ë…¸ë“œë¥¼ keyë¡œ í•˜ëŠ” dictionaryí˜•íƒœë¡œ ì €ì¥í•´ ë†“ëŠ” ê²ƒ!</strong> ì‚¬ì‹¤ ì´ ë¬¸ì œ ë•Œë¬¸ì— ê³¨ë¨¸ë¦¬ë¥¼ ì•“ê³  ìˆì—ˆëŠ”ë°, ì´ ë°©ë²•ì„ ì•Œê²Œ ë˜ê³ ..ì˜¤ì˜¹! í–ˆìŒ ğŸ‘€    

ğŸ“Œ <strong><u>ì´ ë‘˜ì„ ë”°ë¡œ ê¸°ë¡í•˜ëŠ” ì´ìœ </u></strong>    

<strong>ìƒì„±í•œ ë…¸ë“œì™€ ë°©ë¬¸í•œ ë…¸ë“œëŠ” ì—„ì—°íˆ ë‹¤ë¥´ë‹¤</strong>. íŠ¹íˆ í•´ê²° ê³¼ì •ì—ì„œ, ìƒê°í•´ë³´ë©´ ìš°ë¦¬ëŠ” ë…¸ë“œ í•˜ë‚˜ë¥¼ ë°©ë¬¸í•œ í›„, ê·¸ ìì‹ ë…¸ë“œ (ì—¬ê¸°ì„œëŠ” ì´ì›ƒ(<code>neighbors</code>) ë…¸ë“œ..?)ê¹Œì§€ ìƒì„±í•˜ê³ , ì´ë¥¼ ì—°ê²°í•´ì•¼ í•œë‹¤. ì´ ë•Œ ì´ì›ƒ ë…¸ë“œë¥¼ ìƒì„±í•˜ê³  ì—°ê²°í•˜ì§€ ì•Šê³ , ë‚˜ì¤‘ì— ì´ì›ƒ ë…¸ë“œë¥¼ ë°©ë¬¸í•  ë•Œ ìƒì„±í•˜ë©´ ê·¸ ì „ ë…¸ë“œ(ë¶€ëª¨ ë…¸ë“œ)ì™€ ì—°ê²°í•˜ëŠ” ê³¼ì •ì´ ë²ˆê±°ë¡œì›Œì§! (í•  ìˆ˜ëŠ” ìˆì„ ê²ƒ ê°™ê¸´ í•´ë„..)        

</div>

ê·¸ëŸ¼ ë³¸ê²©ì ìœ¼ë¡œ ì½”ë“œë¥¼ í•œ ë²ˆ ì‘ì„±í•´ë³´ì!          

```python
class Solution(object):
    def cloneGraph(self, node):
```   

ì¼ë‹¨ ì²˜ìŒ `input`ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ê·¸ëƒ¥ ë…¸ë“œ ìì²´ë¥¼ ë‹¤ì‹œ ë¦¬í„´í•˜ë©´ ë¨. (ë¹ˆ ë…¸ë“œëŠ” ë‹¤ì‹œ ë§Œë“¤ì§€ ì•Šì•„ë„..ë˜ë‹ˆê¹Œ)             

```python
if not node:
	return node
```

ë‹¤ìŒìœ¼ë¡œ **ë°©ë¬¸í•œ ë…¸ë“œë“¤ì„ ì €ì¥í•  setì¸ `visited`ì™€ ìƒˆë¡œ ìƒì„±í•œ ë…¸ë“œë“¤ì„ ì €ì¥í•  `dictionary`ì¸ `m`ì„ ë§Œë“¤ì–´ì£¼ì**.        

```python
m, visited = dict(), set()    
```

ì´ì œ `dfs`ë¼ëŠ” í•¨ìˆ˜ë¥¼ ìƒê°í•´ë³´ì. ì¼ë‹¨ íŒŒë¼ë¯¸í„°ë¡œëŠ” í˜„ì¬ íƒìƒ‰í•  ë…¸ë“œ `n`ê³¼ ìœ„ì—ì„œ ë§Œë“  `dictionary`, `set()`ì¸ `m`ê³¼ `visited`ë¥¼ ë°›ì•„ì•¼ê² ì§€.              

```python
def dfs(self, n, m, visited):
```

ë§Œì•½ í˜„ì¬ íƒìƒ‰í•˜ê³  ìˆëŠ” ë…¸ë“œê°€ **ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¼ë©´ `return`**í•´ì¤€ë‹¤. `connected graph`ì˜ íƒìƒ‰ì—ì„œ ë¬´í•œ ë£¨í”„ì— ë¹ ì§€ì§€ ì•Šê¸° ìœ„í•œ **`end clause`**!       

```python
if n in visited:
	return 
```   

ì²˜ìŒ ë°©ë¬¸í•˜ëŠ” ë…¸ë“œë¼ë©´, ì¼ë‹¨ **ì´ì œëŠ” ë°©ë¬¸í–ˆìœ¼ë‹ˆ `visited`ì— ì¶”ê°€**í•´ì£¼ì.   
ë‹¤ìŒìœ¼ë¡œ `m`ì— `n`ì´ ì—†ë‹¤ë©´, ì¦‰, **í˜„ì¬ ë³´ê³  ìˆëŠ” ë…¸ë“œê°€ ì•„ì§ ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•Šì€ ë…¸ë“œë¼ë©´, ë°”ë¡œ ìƒì„±**í•´ ì¤€ë‹¤.                

```python
visited.add(n)
if n not in m:
	m[n] = Node(n.val)
```

ì´ì œ í˜„ì¬ ë³´ê³  ìˆëŠ” ë…¸ë“œì˜ **ì´ì›ƒ ë…¸ë“œë“¤ë„, ë§Œì•½ ìƒì„±ë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ ìƒì„±í•˜ê³ , í˜„ì¬ ë…¸ë“œì˜ `neighbors`ë¼ëŠ” í•­ëª©ì— ì¶”ê°€**í•´ì£¼ë©´ ëœë‹¤.       
ê·¸ë¦¬ê³  **ì´ì›ƒ ë…¸ë“œë“¤ì— ëŒ€í•´ì„œë„ ë™ì¼í•˜ê²Œ `dfs`ë¥¼ ì ìš©**í•´ì£¼ë©´ ë˜ê² ì§€?            

```python
for neigh in n.neighbors:
	if neigh not in m:
		m[neigh] = Node(neigh.val)
	m[n].neighbors.append(m[neigh])
	self.dfs(neigh, m, visited)    
```

ë‹¤ì‹œ ì›ë˜ í•¨ìˆ˜ `cloneGraph`ë¡œ ëŒì•„ì™€ë³´ì.     
ì´ì œ í•  ì¼ì€ `dfs`ì— `input node`(`root node`?ë¼ê³  í•´ë„ ë˜ë‚˜?)ë¥¼ ë„£ì–´ ëŒë¦¬ê³ , `m[node]` ì¦‰, `input node`ì— ëŒ€í•´ ìƒˆë¡œ ìƒì„±í•œ ë…¸ë“œë¥¼ ë°˜í™˜í•˜ë©´ ë!              

```python
def dfs(self, n, m, visited):
```
     
### âœï¸ Final Code

   ```python
class Solution(object):
    def cloneGraph(self, node):
        if not node:
            return node
        m, visited = dict(), set()
        self.dfs(node, m, visited)
        return m[node]

    def dfs(self, n, m, visited):
        if n in visited:
            return 
        visited.add(n)
        if n not in m:
            m[n] = Node(n.val)
        for neigh in n.neighbors:
            if neigh not in m:
                m[neigh] = Node(neigh.val)
            m[n].neighbors.append(m[neigh])
            self.dfs(neigh, m, visited)
   ```
 
    	    
<div class="notice--primary" markdown="1">
ğŸŒŸ <strong>[5ì£¼ì°¨] myown_2ì˜ <u>í¬ì¸íŠ¸</u></strong>    

- ë‹¹ì—°íˆ ì¼ë‹¨.. DFS     
- dict(), set()ì„ í•„ìš”ì— ë”°ë¼ ì„œìŠ´ì—†ì´ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ì•¼ê² ë‹¤..      
     
</div>
